过去的近一年我主要参与的项目都是基于react的多页应用——苏打办公，一款以pdf和办公相关功能为核心的软件，参与了原有项目的改造和迁移，也上线了不少需求。其中也遇到了不少问题。

## 1.项目的迁移

​        背景:原有的项目使用的是react和webpack的多页应用，但是原有页面，大多数还是基于main页面的子路由进行拆解，代码时间比较长，目录混乱，加上随着项目复杂性的上升，webpack构建时间过长。于是团队决定将项目的构建工具换成vite,将原有的子路由拆解单独的页面。

1. 项目开始初期遇到了不少的问题,比如最开始页面的路由采用的是history路由，但是忽略了原有项目是基于hash路由，服务器没有对history路由做兼容，所以我们对某个直接跳转某个页面子路由就会出现白屏的现象，虽然是重构，但是项目迁移也应该是渐进式的，应该注意对原有架构的兼容性。着手写代码前，应该对自己所负责的功能有完整的了解，大致确定需要涉及的技术点。首先确定当前方案的可行性，一定要避免开发中途，大幅度变更技术方案。
2. 因为原有的项目本身就比较庞大，重构就涉及到很多的逻辑变更，开发时间也长，但是因为自己开发前也没有对任务进行拆解，所以一次commit里面可能就包含着大量的代码。当遇到代码冲突，或者其他问题的时候，就十分难以定位问题的根源。

## 2.如何合理的处理流式响应

   背景:前端实现打字机效果，需对后端返回的流进行改造，拼接。
        传统的请求都是基于ajax发起的请求，我们对获取的数据只能进行一次接收，该请求就结束，但是我们要持续的接收后端返回的结果，就要放弃ajax。
      然后调研了业界主流的处理方案，主要是分为采用EventSource或者Fetch来接收数据，于是我们分别对两个api做了对比。

| 特性     | EventSource                                                  | fetch API                                                    |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 兼容性   | 广泛支持，包括Internet Explorer 8及更高版本                  | 在较新的浏览器中得到支持，不完全支持Internet Explorer        |
| 数据格式 | 只支持服务器发送的文本数据，自动转换为文本                   | 可以获取包括文本、JSON、Blob等在内的各种数据格式             |
| 错误处理 | 自动尝试重新连接，可以监听'error'事件来处理错误              | 没有内置的重试机制，需要手动处理错误并可能需要进行重试       |
| 流式处理 | 支持简单处理服务器发送的流式数据                             | 不直接支持流式处理，但可以使用Response对象的body属性获取流式接口 |
| CORS问题 | 受同源策略限制，除非服务器配置了适当的CORS头，否则无法跨源加载 | 不受同源策略限制，可以跨源请求数据，但需要服务器配置适当的CORS头 |
| 灵活性   | 只能发送GET请求，拼接字符串传参                              | 可以发起任意类型请求。传参灵活                               |

​         于是最后采用的fetch来作为解决方案，但是这只是解决了第一个问题。然后就是fetch读取的数据，具体实现中也会遇到很多问题。下面是示例代码。

```javascript
后端返回的数据结构
//data: {"content":" \n\n"}

//data: {"content":"克服"}

//data: {"content":"拖延"}

//data: {"content":"症"}

//data: {"content":"?"}
//null 结尾
async function fetchDataAndDisplay() {
  const url = 'your-backend-url'; 
  const response = await fetch(url, { stream: true });
  const reader = response.body.getReader();

  let outputElement = document.getElementById('output');
  let text = '';

  while (reader) {
    try {
      const { value, done } = await reader.read()
      const chars = new TextDecoder().decode(value)
      if (chunk.value === '' ||done) {
        break; 
      }
      const dataArray = chars.trim().split('\n\n')
      const jsonObjects = dataArray.map(data => {
        if (data === 'null' || !data) {
          return { content: '' }
        }
        const jsonString = data.substring('data: '.length)
        return JSON.parse(jsonString) as { content: string }
      })
      let text=''
      jsonObjects.forEach(item => {
        text += item.content
      })
      console.log('text',text)
    } catch (err) {
      console.error(err);
    }
  }
}
```

​        首先，我们需要将返回的unit8Array转换为中文字符串。

​        然后，我们可以通过正则表达式来匹配出每个数据结构中content的value值。但是，这种方法可能会比较复杂，因为我们需要先解析出整个数据结构，然后再进行匹配。此外，正则表达式也可能因为数据结构的复杂性而变得难以维护。

​        另一种方法是使用JSON.parse将unit8Array转换为JSON对象。这种方法的好处是对象的属性操作和读取都更加方便。但是，如果使用不当，JSON.parse很容易抛出错误，导致程序中断。因此，在处理时需要特别小心。

​       同时，后端返回的数据格式也有不可控的情况。因此，我们需要对数据进行检查和处理，以确保程序的稳定性和可靠性。

## 3.从0到一的项目开发

